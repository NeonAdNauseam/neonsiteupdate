<section class="mobile-panel mobile-panel--exterior">
  <h1>Welcome to the Store! Scroll to enter</h1>

  <div class="store-exterior">
    <div class="parallax-container">
      <!-- background image -->
      <img
        src="https://raw.githubusercontent.com/NeonAdNauseam/Portfolio-API-and-Images/main/nonportfolioAssets/konbiniexample.png"
        alt="Street background"
        class="scene-bg"
      />

      <!-- Track 1 -->
      <svg
        class="parallax-track"
        id="mobileTrack1Svg"
        viewBox="0 0 1920 1080"
        preserveAspectRatio="xMidYMid slice"
      >
        <defs></defs>
      </svg>

      <!-- Track 2 -->
      <svg
        class="parallax-track"
        id="mobileTrack2Svg"
        viewBox="0 0 1920 1080"
        preserveAspectRatio="xMidYMid slice"
      >
        <defs></defs>
      </svg>
    </div>
  </div>
</section>

<style>
  .mobile-panel {
    width: 100%;
    padding: 1.5rem 1rem 3rem;
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }

  .mobile-panel--exterior {
    background: var(--store-bg);
    color: var(--store-text-color);

    h1 {
      text-align: center;
      margin: 1.5rem 1rem 0.75rem;
      font-family: var(--store-font-family);
      font-size: 1.1rem;
    }

    .store-exterior {
      width: 100%;
      max-width: 100%;
      min-height: 70vh;
      background: var(--store-bg);
      position: relative;
      overflow: hidden;

      .parallax-container {
        position: relative;
        width: 100%;
        height: 100%;

        .scene-bg {
          position: absolute;
          inset: 0;
          width: 100%;
          height: 100%;
          /* hard coded so we avoid the weird var lag */

          object-position: center;
          z-index: var(--scene-bg-z);
          pointer-events: none;
        }

        .parallax-track {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
        }

        #mobileTrack1Svg {
          z-index: var(--track1-z);
        }

        #mobileTrack2Svg {
          z-index: var(--track2-z);
        }
      }

  
      }
    }

</style>






<script>
// @ts-nocheck

  // ===================== CONFIG TOKENS =====================
  const MOBILE_CAR_SHAPES_API_URL = "/JSON/carShapes.json"
  const MOBILE_BASE_DISTANCE = 2300

  const MOBILE_TRACK_DIRECTIONS = {
    track1: "right",
    track2: "left"
  }

  const MOBILE_TRACK_CONFIG = {
    track1: {
      scale: 1.25,
      y: 650,
      speed: 8,
      minDelay: 4000,
      maxDelay: 16000
    },
    track2: {
      scale: 0.75,
      y: 575,
      speed: 7,
      minDelay: 4000,
      maxDelay: 16000
    }
  }

  const MOBILE_TRACK_ID_MAP = {
    track1: "mobileTrack1Svg",
    track2: "mobileTrack2Svg"
  }

  // ===================== STATE =====================
  const mobileTrackShapes = {
    track1: [],
    track2: []
  }

  const mobileTrackTimers = {
    track1: null,
    track2: null
  }

  const mobileLastSpawned = {
    track1: null,
    track2: null
  }

  let mobileAnimationActive = true

  // ===================== UTILS =====================
  function mobileRandomInRange(min, max) {
    return min + Math.random() * (max - min)
  }

  // ===================== LOAD SHAPES =====================
  async function loadMobileCarShapes() {
    let config

    try {
      const res = await fetch(MOBILE_CAR_SHAPES_API_URL)
      if (!res.ok) {
        console.warn("[mobile exterior] carShapes.json fetch failed", res.status)
        return
      }
      config = await res.json()
      console.log("[mobile exterior] carShapes config", config)
    } catch (err) {
      console.error("[mobile exterior] error fetching carShapes.json", err)
      return
    }

    const svgNs = "http://www.w3.org/2000/svg"

    for (const [laneKey, shapes] of Object.entries(config)) {
      const svgId = MOBILE_TRACK_ID_MAP[laneKey]
      const trackSvg = document.getElementById(svgId)
      if (!trackSvg) {
        console.warn("[mobile exterior] SVG not found for lane", laneKey, svgId)
        continue
      }

      let defs = trackSvg.querySelector("defs")
      if (!defs) {
        defs = document.createElementNS(svgNs, "defs")
        trackSvg.appendChild(defs)
      }

      for (const shape of shapes) {
        const { id, src } = shape
        try {
          const svgRes = await fetch(src)
          if (!svgRes.ok) {
            console.warn("[mobile exterior] failed to fetch car SVG", src, svgRes.status)
            continue
          }

          const svgText = await svgRes.text()
          const doc = new DOMParser().parseFromString(svgText, "image/svg+xml")
          const sourceRoot = doc.documentElement

          let sourceGroup = sourceRoot.querySelector("g")
          if (!sourceGroup) {
            sourceGroup = sourceRoot
          }

          const templateGroup = document.createElementNS(svgNs, "g")
          templateGroup.setAttribute("id", id)

          Array.from(sourceGroup.children).forEach(node => {
            templateGroup.appendChild(
              document.importNode(node, true)
            )
          })

          defs.appendChild(templateGroup)
          mobileTrackShapes[laneKey].push(id)
        } catch (err) {
          console.error("[mobile exterior] error loading SVG", src, err)
        }
      }
    }

    console.log("[mobile exterior] mobileTrackShapes", mobileTrackShapes)
  }

  // ===================== SPAWN CARS =====================
  function spawnMobileCar(svgRoot, laneKey, scaleFactor, speedSec, yParam) {
    if (!svgRoot || !window.gsap || !mobileAnimationActive) return

    const shapes = mobileTrackShapes[laneKey] || []
    if (!shapes.length) return

    const direction = MOBILE_TRACK_DIRECTIONS[laneKey] || "right"

    const shapeIndex = Math.floor(Math.random() * shapes.length)
    const shapeId = shapes[shapeIndex]

    const template = document.getElementById(shapeId)
    if (!template) return

    const newCar = template.cloneNode(true)
    newCar.removeAttribute("id")
    svgRoot.appendChild(newCar)

    let yPos = 200
    if (Array.isArray(yParam) && yParam.length > 0) {
      yPos = yParam[0]
    } else if (typeof yParam === "number") {
      yPos = yParam
    }

    const scaleX = direction === "right" ? scaleFactor : -scaleFactor

    gsap.set(newCar, {
      x: 0,
      y: yPos,
      scaleX: scaleX,
      scaleY: scaleFactor,
      transformOrigin: "top left"
    })

    const bbox = newCar.getBBox()
    const shapeWidth = bbox.width * scaleFactor

    let startX
    let finalX

    if (direction === "right") {
      startX = -300 - shapeWidth
      finalX = 2000
    } else {
      startX = 2000 + shapeWidth
      finalX = -300
    }

    gsap.set(newCar, { x: startX })

    const totalDistance = MOBILE_BASE_DISTANCE + shapeWidth
    const baseVelocity = MOBILE_BASE_DISTANCE / speedSec
    const duration = totalDistance / baseVelocity

    gsap.to(newCar, {
      x: finalX,
      duration,
      ease: "none",
      onComplete: () => {
        newCar.remove()
      }
    })

    mobileLastSpawned[laneKey] = newCar
  }

  // ===================== SCHEDULE LANES =====================
  function setupMobileParallaxTracks() {
    if (!window.gsap) {
      console.warn("[mobile exterior] GSAP not found, car animation disabled.")
      return
    }

    function scheduleMobileTrack(laneKey) {
      const svgId = MOBILE_TRACK_ID_MAP[laneKey]
      const svgRoot = document.getElementById(svgId)
      const cfg = MOBILE_TRACK_CONFIG[laneKey]

      if (!svgRoot || !cfg) return

      const spawnAndReschedule = () => {
        if (!mobileAnimationActive) return
        spawnMobileCar(svgRoot, laneKey, cfg.scale, cfg.speed, cfg.y)
        const delay = mobileRandomInRange(cfg.minDelay, cfg.maxDelay)
        mobileTrackTimers[laneKey] = setTimeout(spawnAndReschedule, delay)
      }

      spawnAndReschedule()
    }

    scheduleMobileTrack("track1")
    scheduleMobileTrack("track2")
  }

  // ===================== INIT =====================
  window.addEventListener("DOMContentLoaded", () => {
    // only run this on mobile widths, and only if this panel exists
    const isMobile = window.matchMedia("(max-width: 768px)").matches
    if (!isMobile) return

    const mobilePanel = document.querySelector(".mobile-panel--exterior")
    if (!mobilePanel) return

    loadMobileCarShapes().then(() => {
      setupMobileParallaxTracks()
    })
  })
</script>


