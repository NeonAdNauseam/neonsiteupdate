<div class="face-inner">
  <div class="parallax-scene-2">
    <div class="scene-canvas" id="parallax-scene-2">
      <!-- background with ice cream machine / window -->
      <img
        src="/assets/face2/window.png"
        alt="Store background"
        class="layer layer-bg"
      />

      <!-- car tracks outside the window -->
      <svg
        class="car-track"
        id="face2Track1Svg"
        viewBox="0 0 1920 1080"
        preserveAspectRatio="xMidYMid slice"
      >
        <defs></defs>
      </svg>

      <svg
        class="car-track"
        id="face2Track2Svg"
        viewBox="0 0 1920 1080"
        preserveAspectRatio="xMidYMid slice"
      >
        <defs></defs>
      </svg>

      <!-- foreground shelf in front of cars and bg -->
      <img
        src="/assets/face2/shelf.png"
        alt="Shop wall"
        class="layer layer-wall"
      />
    </div>
  </div>
</div>

<style>

  :root {
  --face2-scene-width: 1280px;
  --face2-scene-height: 720px;
  --face2-perspective: 800px;

  --face2-bg-z: 0;
  --face2-cars-back-z: 4;   /* green lane */
  --face2-cars-front-z: 5;  /* black lane */
  --face2-shelf-z: 0;
}

.face-inner {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  position: relative;

  .parallax-scene-2 {
    position: absolute;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
    z-index: 0;
  }

  .parallax-scene {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    perspective: var(--face2-perspective);
  }

  .scene-canvas {
    width: var(--face2-scene-width);
    height: var(--face2-scene-height);
    position: relative;
    transform: scale(calc(100vw / var(--face2-scene-width)));
    transform-origin: top left;
  }

  .layer {
    position: absolute;
    pointer-events: none;
    transition: transform 0.1s ease-out;
    will-change: transform;
  }

  .layer-bg {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: var(--face2-bg-z);
    object-fit: contain;
    object-position: center;
    background-color: #050505;
  }

  .car-track {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  /* black cars in front lane */
  #face2Track1Svg {
    z-index: var(--face2-cars-front-z);
  }

  /* green cars in back lane */
  #face2Track2Svg {
    z-index: var(--face2-cars-back-z);
  }

  .layer-wall {
    width: 154.9%;
    top: -41.61%;
    left: -34.5%;
    z-index: var(--face2-shelf-z);
  }
}

</style>

<script is:inline>
  // ================================
  // Config / tunables
  // ================================
  const FACE2_BASE_DISTANCE = 2300;
  const CAR_SHAPES_API_URL = "/JSON/carShapes.json";

  // carShapes.json structure:
  // {
  //   "track1": [{ "id": "blackCar", "src": "/assets/svgs/cars/sampleBlackCar.svg" }],
  //   "track2": [{ "id": "greenCar", "src": "/assets/svgs/cars/sampleCarGreen.svg" }]
  // }

  // Map generic lanes to this face's SVG ids
  const face2LaneToSvgId = {
    track1: "face2Track1Svg",
    track2: "face2Track2Svg"
  };

  // Shapes per lane for this face:
  // { track1: ["blackCar", ...], track2: ["greenCar", ...] }
  const face2TrackShapes = {
    track1: [],
    track2: []
  };

  const face2TrackDirections = {
    track1: "right",
    track2: "left"
  };

  const face2LastSpawned = {
    track1: null,
    track2: null
  };

  const face2TrackConfig = {
    track1: {
      scale: 1.0,
      y: 400,
      speed: 8,
      minDelay: 4000,
      maxDelay: 16000
    },
    track2: {
      scale: 0.75,
      y: 340,
      speed: 7,
      minDelay: 4000,
      maxDelay: 16000
    }
  };

  function face2RandomInRange(min, max) {
    return min + Math.random() * (max - min);
  }

  async function loadFace2CarShapes() {
    let config;

    try {
      const res = await fetch(CAR_SHAPES_API_URL);
      if (!res.ok) {
        console.warn("[face2] carShapes.json fetch failed", res.status);
        return;
      }
      config = await res.json();
      console.log("[face2] carShapes config", config);
    } catch (err) {
      console.error("[face2] error fetching carShapes.json", err);
      return;
    }

    const svgNs = "http://www.w3.org/2000/svg";

    for (const [laneKey, shapes] of Object.entries(config)) {
      // Only care about lanes we have SVGs for in this face
      const svgId = face2LaneToSvgId[laneKey];
      if (!svgId) continue;

      const trackSvg = document.getElementById(svgId);
      if (!trackSvg) {
        console.warn("[face2] SVG not found for lane", laneKey, svgId);
        continue;
      }

      let defs = trackSvg.querySelector("defs");
      if (!defs) {
        defs = document.createElementNS(svgNs, "defs");
        trackSvg.appendChild(defs);
      }

      for (const shape of shapes) {
        const { id, src } = shape;
        try {
          const svgRes = await fetch(src);
          if (!svgRes.ok) {
            console.warn("[face2] failed to fetch car SVG", src, svgRes.status);
            continue;
          }

          const svgText = await svgRes.text();
          const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
          const sourceRoot = doc.documentElement;

          // Use first <g> if present, fallback to root
          let sourceGroup = sourceRoot.querySelector("g");
          if (!sourceGroup) {
            sourceGroup = sourceRoot;
          }

          const templateGroup = document.createElementNS(svgNs, "g");
          templateGroup.setAttribute("id", id);

          Array.from(sourceGroup.children).forEach(node => {
            templateGroup.appendChild(document.importNode(node, true));
          });

          defs.appendChild(templateGroup);
          face2TrackShapes[laneKey].push(id);
        } catch (err) {
          console.error("[face2] error loading SVG", src, err);
        }
      }
    }

    console.log("[face2] face2TrackShapes", face2TrackShapes);
  }

function spawnFace2Car(svgRoot, laneKey, scaleFactor, speedSec, baseY) {
  if (!svgRoot || !window.gsap) return;

  const shapes = face2TrackShapes[laneKey] || [];
  if (!shapes.length) return;

  const direction = face2TrackDirections[laneKey] || "right";

  const shapeIndex = Math.floor(Math.random() * shapes.length);
  const shapeId = shapes[shapeIndex];

  const template = document.getElementById(shapeId);
  if (!template) return;

  const newCar = template.cloneNode(true);
  newCar.removeAttribute("id");
  svgRoot.appendChild(newCar);

  const yPos = baseY ?? 200; // one Y per lane

  const scaleX = direction === "right" ? scaleFactor : -scaleFactor;

  gsap.set(newCar, {
    x: 0,
    y: yPos,
    scaleX: scaleX,
    scaleY: scaleFactor,
    transformOrigin: "top left"
  });

  const bbox = newCar.getBBox();
  const shapeWidth = bbox.width * scaleFactor;

  let startX;
  let finalX;

  if (direction === "right") {
    startX = -300 - shapeWidth;
    finalX = 2000;
  } else {
    startX = 2000 + shapeWidth;
    finalX = -300;
  }

  gsap.set(newCar, { x: startX });

  const totalDistance = FACE2_BASE_DISTANCE + shapeWidth;
  const baseVelocity = FACE2_BASE_DISTANCE / speedSec;
  const duration = totalDistance / baseVelocity;

  gsap.to(newCar, {
    x: finalX,
    duration,
    ease: "none",
    onComplete: () => {
      newCar.remove();
    }
  });

  face2LastSpawned[laneKey] = newCar;
}


  function setupFace2Cars() {
    if (!window.gsap) {
      console.warn("[face2] GSAP not found, animation disabled.");
      return;
    }

    function scheduleFace2Track(laneKey) {
      const svgId = face2LaneToSvgId[laneKey];
      const svgRoot = document.getElementById(svgId);
      const cfg = face2TrackConfig[laneKey];

      if (!svgRoot || !cfg) return;

      const spawnAndReschedule = () => {
        spawnFace2Car(svgRoot, laneKey, cfg.scale, cfg.speed, [cfg.y]);
        const delay = face2RandomInRange(cfg.minDelay, cfg.maxDelay);
        setTimeout(spawnAndReschedule, delay);
      };

      spawnAndReschedule();
    }

    scheduleFace2Track("track1");
    scheduleFace2Track("track2");
  }

  window.addEventListener("DOMContentLoaded", () => {
    loadFace2CarShapes().then(() => {
      setupFace2Cars();
    });
  });
</script>
